الگوریتمی طراحی کنید که اگر برای مدتی نامتناهی به اجرا گذاشته شود همهٔ توتولوژی‌های منطق گزاره‌ها را خروجی دهد. ثابت کنید الگوریتمتان کار خواسته‌شده را به‌درستی انجام می‌دهد.
\begin{ans}
تابع $g$ را به شکل زیر تعریف می‌کنیم:
$$
g(A)=
\begin{cases}
2\cdot 3^{n+1} & \text{if}~~A = p_n\\
2^2\cdot 3^{g(A_1)} & \text{if}~~A=(\neg A_1)\\
2^3\cdot 3^{g(A_1)}\cdot 5^{g(A_2)} & \text{if}~~A=(A_1\wedge A_2) \\
2^4\cdot 3^{g(A_1)}\cdot 5^{g(A_2)} & \text{if}~~A=(A_1\vee A_2) \\
2^5\cdot 3^{g(A_1)}\cdot 5^{g(A_2)} & \text{if}~~A=(A_1\rightarrow A_2)
\end{cases}
$$
واضح است که این تابع به هر فرمول عددی یکتا نسبت می‌دهد. اگر یک عدد ورودی بگیریم، به‌سادگی می‌توانیم با تجزیهٔ آن عدد به عوامل اول بررسی کنیم آیا این عدد در یکی از عبارات تعریف $g$ قرار می‌گیرد یا نه، و در صورت لزوم همین کار را دربارهٔ توان عوامل اول آن نیز انجام بدهیم تا نهایتاً تعیین کنیم آیا فرمولی وجود دارد که تابع $g$ به آن این عدد را نسبت بدهد یا نه و اگر چنین فرمولی وجود دارد این فرمول چیست. پس از بازسازی فرمول، به‌سادگی می‌توان اتم‌های آن را مشخص کرد و با ترسیم جدول‌ارزش توتولوژی بودن آن را تعیین کرد. واضح است که برای هر عدد طبیعی هر دوی این مراحل در زمان متناهی پایان می‌پذیرند. حال یک رایانه می‌تواند به‌ترتیب این فرمول را روی همهٔ اعداد طبیعی از کوچک به بزرگ انجام بدهد و هر گاه به عددی می‌رسد که فرمول متناظرش توتولوژی است آن را چاپ کند. این برنامه اگر به مدت نامتناهی به اجرا گذاشته شود همهٔ توتولوژی‌ها را خروجی می‌دهد زیرا به ازای هر توتولوژی $A$، این الگوریتم نهایتاً به
$g(A)$
می‌رسد و پس از بازسازی $A$ از روی $g(A)$ و بررسی توتولوژی بودنش آن را خروجی می‌دهد.
\end{ans}